apply plugin: 'com.android.library'
//import java.io.File

enum JNIUsingMode{
    /*
    Don't make JNILibs, just copy them from network.
    * */
    using_jnilibs_directly,
    /*
    In this mode, there is a crash on armeabi-v7a platform(phread pure abort).
    This mode is uesful for debugging
    * */
    compiling_by_origin_task_with_origin_cmake_cfg,
    /*
    Because of using custom-cmake-cfg, cause a gradle Sync error(abi missing) while in Android Studio.
    But it is ok for 'gradle command line mode'(both on linux and windows).
    * */
    compiling_by_origin_task_with_custom_cmake_cfg,
    /*
    Using custom-gradle-task and custom-cmake-cfg to compile JNI. It is ok for 'gradle command line mode' and Android Studio
    * */
    compiling_by_custom_task_with_custom_cmake_cfg,
}

ext {
    autoJniMode = true
    jniMode = JNIUsingMode.compiling_by_origin_task_with_custom_cmake_cfg
    isWindows = System.getProperty("os.name").startsWith("Windows")
    isMacOS = System.getProperty("os.name").startsWith("Mac")
    if(autoJniMode && (isWindows || isMacOS)) {
        jniMode = JNIUsingMode.using_jnilibs_directly
    }

    compiler_type = "gcc"
    cmakefile_path = "CMakeLists.txt"
    make_program = "Ninja" // Ninja or Makefile
    build_type = "Debug"
    abi_filters = ['armeabi-v7a', 'x86_64'] //'armeabi-v7a', 'arm64-v8a', 'x86_64'
    custom_cmake_cfg = "scripts/android.standalone.toolchain.cmake"
    c_compile_flags = [
            "-DLINUX", "-DANDROID"
    ]
    cxx_compile_flags = [
            "-DLINUX", "-DANDROID", "-std=c++11"
    ]
    jniDepClasses = [
            file('build/intermediates/classes/release/sanp/avalon/libs/network/protocol/RTSPClient.class'),
            file('build/intermediates/classes/release/sanp/avalon/libs/network/protocol/RTMPPushClient.class'),
            file('build/intermediates/classes/release/sanp/avalon/libs/network/protocol/RTMPBandwidthTest.class'),
    ]
    jniHeads = [
            file('src/main/cpp/sanp_avalon_libs_network_protocol_RTSPClient.h'),
            file('src/main/cpp/sanp_avalon_libs_network_protocol_RTMPPushClient.h'),
            file('src/main/cpp/sanp_avalon_libs_network_protocol_RTMPBandwidthTest.h'),
    ]
    tmpJNILibs = "\\\\nas.3bu.cn\\temp\\tuyj\\jniLibs"

    Properties properties = new Properties()
    properties.load(rootProject.file('local.properties').newDataInputStream())
    sdk_home = properties.getProperty('sdk.dir')
    if(sdk_home == null)
        throw new RuntimeException("Lost 'sdk.dir' property in 'local.properties'")
    if(jniMode == JNIUsingMode.compiling_by_origin_task_with_custom_cmake_cfg ||
            jniMode == JNIUsingMode.compiling_by_custom_task_with_custom_cmake_cfg) {
        ndk_home = properties.getProperty('ndk.dir')
        if(ndk_home == null)
            throw new RuntimeException("Lost 'ndk.dir' property in 'local.properties'")
        toolchains_home = properties.getProperty('toolchains.dir')
        if(toolchains_home == null)
            throw new RuntimeException("Lost 'toolchains.dir' property in 'local.properties'. It looks like '/opt'")
    }
    runClean = false // don't modify it manually
    compilingByOrigin = false
    library_out_dir0 = String.join(File.separator, [projectDir.toString(), "src", "main", "jniLibs"])
    avalon_dir = String.join(File.separator, [projectDir.toString(), "src", "main", "cpp", "avalon"])
    if (jniMode == JNIUsingMode.compiling_by_origin_task_with_origin_cmake_cfg) {
        compilingByOrigin = true
        cmake_arguments = ["-DANDROID_TOOLCHAIN="+compiler_type]
    } else if (jniMode == JNIUsingMode.compiling_by_origin_task_with_custom_cmake_cfg) {
        compilingByOrigin = true
        cmake_arguments = [
                "-DTOOLCHAIN_COMPILER="+compiler_type,
                "-DTOOLCHAIN_TOP_DIR="+toolchains_home,
                "-DCMAKE_TOOLCHAIN_FILE="+custom_cmake_cfg,
        ]
    } else if (jniMode == JNIUsingMode.compiling_by_custom_task_with_custom_cmake_cfg) {
        def pending = "%s"
        cmake_bin_dir = new File(sdk_home + File.separator + "cmake").listFiles().sort()[-1].toString() + File.separator + "bin";
        library_out_dir = String.join(File.separator, [projectDir.toString(), "src", "main", "jniLibs", pending /*TARGET_ABI*/])
        cmake_build_dir0 = String.join(File.separator, [projectDir.toString(), ".externalNativeBuild", "cmake.custom", pending /*BUILD_TYPE*/])
        cmake_build_dir = String.join(File.separator, [projectDir.toString(), ".externalNativeBuild", "cmake.custom", pending /*BUILD_TYPE*/, pending /*TARGET_ABI*/])
        make_program_bin = cmake_bin_dir + File.separator + "ninja"
        def make_program_name = "Android Gradle - Ninja"
        if (make_program == "Makefile") {
            make_program_bin = "make"
            make_program_name = "Android Gradle - Unix Makefiles"
        }
        cmake_arguments = [
                String.format('-H"%s"', projectDir),
                String.format('-G"%s"', make_program_name),
                String.format('-DCMAKE_MAKE_PROGRAM="%s"', make_program_bin),
                String.format('-DANDROID_NDK="%s"', ndk_home),
                String.format('-DCMAKE_BUILD_TYPE="%s"', build_type),
                String.format('-DCMAKE_C_FLAGS="%s"', String.join(" ", c_compile_flags)),
                String.format('-DCMAKE_CXX_FLAGS="%s"', String.join(" ", cxx_compile_flags)),
                String.format('-DTOOLCHAIN_COMPILER="%s"', compiler_type),
                String.format('-DTOOLCHAIN_TOP_DIR="%s"', toolchains_home),
                String.format('-DCMAKE_TOOLCHAIN_FILE="%s"', custom_cmake_cfg),
        ]
        cmake_pending_arguments = [
                '-B"%s"'                                /*cmake_build_dir + TARGET_ABI*/,
                '-DCMAKE_LIBRARY_OUTPUT_DIRECTORY="%s"' /*library_out_dir + TARGET_ABI*/,
                '-DANDROID_ABI="%s"'                    /*TARGET_ABI*/,
                '-DANDROID_NATIVE_API_LEVEL="%s"'       /*API_LEVEL*/,
        ]
    }
    if (isWindows) {
        cmd_prefix = ["cmd", "/c"]
        script_prefix = ""
        script_suffix = ".bat"
        multi_line_seq = " ^"
    } else {
        cmd_prefix = ["sh", "-c"]
        script_prefix = "sh"
        script_suffix = ".sh"
        multi_line_seq = " \\"
    }
}

android {
    compileSdkVersion 26
    buildToolsVersion "26.0.2"

    defaultConfig {
        minSdkVersion 21
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        if (compilingByOrigin) {
            externalNativeBuild {
                cmake {
                    for(String cFlag: c_compile_flags) {
                        cFlags cFlag
                    }
                    for(String cFlag: cxx_compile_flags) {
                        cppFlags cFlag
                    }
                    for(String argument: cmake_arguments) {
                        arguments argument
                    }
                }
            }
            ndk {
                // Specifies the ABI configurations of your native
                // libraries Gradle should build and package with your APK.
                for(String abiFilter: abi_filters) {
                    abiFilters abiFilter
                }
            }
        }
    }

    if (compilingByOrigin) {
        externalNativeBuild {
            cmake {
                path cmakefile_path
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            jniDebuggable true
        }
    }
}

dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:25.1.1'
    compile 'org.xutils:xutils:3.3.40'
    compile 'org.greenrobot:eventbus:3.0.0'
    compile files('libs/zixing-core-3.2.0.jar')
    provided 'com.google.code.gson:gson:2.8.0'
    testCompile 'junit:junit:4.12'
}

task checkScripts(type: Exec) {
    if(isWindows) {
        commandLine cmd_prefix + ["echo !!!! nothing to do in checkScripts"]
    } else {
        def cmd = "chmod +x " + String.join(File.separator, [projectDir.toString(), 'scripts', '*'])
        commandLine cmd_prefix + [cmd]
    }
}

task genJniHead(type: Exec, dependsOn: 'compileReleaseJavaWithJavac') {
    inputs.files jniDepClasses
    inputs.property("jniDepClasses", jniDepClasses)
    inputs.property("jniHeads", jniHeads)
    outputs.files jniHeads
    workingDir  projectDir.toString() + File.separator + "scripts"

    if (jniMode == JNIUsingMode.using_jnilibs_directly) {
        commandLine cmd_prefix + ["echo !!!! nothing to do in genJniHead"]
        return
    }

    if(isWindows) {
        commandLine cmd_prefix + ["gen_jni_head.bat"]
    } else {
        commandLine cmd_prefix + ["sh gen_jni_head.sh " + sdk_home]
    }
}
genJniHead.dependsOn checkScripts
//tasks.compileLint.dependsOn genJniHead

task cleanJniHead(type: Delete) {
    delete jniHeads
    doLast {
        runClean = true
    }
}
rootProject.clean.dependsOn cleanJniHead

task copyAvalon(type: Exec) {
    workingDir  projectDir.toString() + File.separator + "scripts"

    if (jniMode == JNIUsingMode.using_jnilibs_directly) {
        commandLine cmd_prefix + ["echo !!!! nothing to do in copyAvalon"]
        return
    }
    File file = new File(avalon_dir);
    if(!file.exists() || (file.isDirectory() && file.list().length == 0))
        commandLine cmd_prefix + ["python avalon_copy.py -c avalon_deps.json -o" + avalon_dir.toString()]
    else
        commandLine cmd_prefix + [String.format("echo !!!! %s is not empty, copyAvalon Skipped", avalon_dir)]
}

private void outputCmd(String filename, String cmd, List<String> params) {
    def debug_str = String.format("%s%s\n%s", cmd, multi_line_seq, String.join(multi_line_seq+'\n', params))
    def out = new FileOutputStream(new File(filename));
    out.write(debug_str.getBytes());
    out.close()
}

private int getApiLevel(String abi) {
    def api_lvl = 19
    if(abi in ['arm64-v8a', 'x86_64'])
        api_lvl = 21
    if(api_lvl < project.android.defaultConfig.minSdkVersion.mApiLevel)
        api_lvl = project.android.defaultConfig.minSdkVersion.mApiLevel
    return api_lvl
}

private boolean createDir(String path) {
    File dirname = new File(path);
    if (dirname.exists()) {
        if (dirname.isDirectory())
            return false
        throw new RuntimeException(path + "is not a Directory")
    }
    return dirname.mkdirs()
}

private static boolean deleteDir(String path) {
    return deleteDir(new File(path))
}

private static boolean deleteDir(File dir) {
    if (dir.isDirectory()) {
        String[] children = dir.list();
        for (int i=0; i<children.length; i++) {
            boolean success = deleteDir(new File(dir, children[i]));
            if (!success) {
                return false;
            }
        }
    }
    return dir.delete();
}

private boolean reCreateDir(String path) {
    File dirname = new File(path);
    if (dirname.exists()) {
        if (!dirname.isDirectory())
            throw new RuntimeException(path + "is not a Directory")
        if(deleteDir(dirname))
            println "Delete directory " + path
    }
    println "reCreate directory " + path
    return dirname.mkdirs()
}

task cfgJni(type: Exec, dependsOn: 'genJniHead') {
    if(jniMode == JNIUsingMode.compiling_by_custom_task_with_custom_cmake_cfg) {
        inputs.files file(projectDir.toString() + File.separator + cmakefile_path)
        inputs.property("compiler_type", compiler_type)
        inputs.property("cmakefile_path", cmakefile_path)
        inputs.property("make_program", make_program)
        inputs.property("build_type", build_type)
        inputs.property("abi_filters", abi_filters)
        inputs.property("custom_cmake_cfg", custom_cmake_cfg)
        inputs.property("c_compile_flags", c_compile_flags)
        inputs.property("cxx_compile_flags", cxx_compile_flags)
        inputs.property("ndk_home", ndk_home)
        inputs.property("toolchains_home", toolchains_home)
        inputs.property("api_lvl", project.android.defaultConfig.minSdkVersion.mApiLevel)
        for(String abi: abi_filters) {
            def cmake_build_dir_impl = String.format(cmake_build_dir, build_type.toString().toLowerCase(), abi)
            outputs.files file(cmake_build_dir_impl + File.separator + "build.ninja")
        }
        workingDir  projectDir.toString() + File.separator + "scripts"
    }

    doFirst{
        if (jniMode == JNIUsingMode.using_jnilibs_directly) {
            commandLine cmd_prefix + ["echo !!!! Will not cfg jni"]
            return
        } else if (jniMode == JNIUsingMode.compiling_by_origin_task_with_origin_cmake_cfg) {
            commandLine cmd_prefix + ["echo !!!! Will cfg jni by origin task with origin cmake cfg"]
            return
        } else if (jniMode == JNIUsingMode.compiling_by_origin_task_with_custom_cmake_cfg) {
            commandLine cmd_prefix + ["echo !!!! Will cfg jni by origin task with custom cmake cfg"]
            return
        } else if (jniMode == JNIUsingMode.compiling_by_custom_task_with_custom_cmake_cfg) {
            println "!!!! Will cfg jni by custom task with custom cmake cfg"
        } else {
            throw new RuntimeException("Unknow JNIUsingMode:" + jniMode)
        }

        def cmake_bin = cmake_bin_dir + File.separator + "cmake"
        def cmake_build_dir0_imple = String.format(cmake_build_dir0, build_type.toString().toLowerCase())
        deleteDir(cmake_build_dir0_imple)
        deleteDir(library_out_dir0)
        for(String abi: abi_filters) {
            def api_lvl = getApiLevel(abi)
            def cmake_build_dir_impl = String.format(cmake_build_dir, build_type.toString().toLowerCase(), abi)
            def library_out_dir_impl = String.format(library_out_dir, abi)

            reCreateDir(library_out_dir_impl)
            reCreateDir(cmake_build_dir_impl)

            String[] cmake_impl_arguments = new String[cmake_pending_arguments.size()]
            cmake_impl_arguments[0] = String.format(cmake_pending_arguments[0], cmake_build_dir_impl)
            cmake_impl_arguments[1] = String.format(cmake_pending_arguments[1], library_out_dir_impl)
            cmake_impl_arguments[2] = String.format(cmake_pending_arguments[2], abi)
            cmake_impl_arguments[3] = String.format(cmake_pending_arguments[3], api_lvl)
            List<String> cmake_all_arguments  = new ArrayList<>()
            cmake_all_arguments.addAll(cmake_arguments)
            cmake_all_arguments.addAll(cmake_impl_arguments)

            outputCmd(cmake_build_dir_impl + File.separator + "cmake_build_command" + script_suffix, cmake_bin, cmake_all_arguments);
        }
        commandLine cmd_prefix + [String.format("%s configure%s %s", script_prefix, script_suffix, cmake_build_dir0_imple)]
    }
}
//tasks.compileLint.dependsOn cfgJni

task makeJni(type: Exec, dependsOn: 'cfgJni') {
    workingDir  projectDir.toString() + File.separator + "scripts"

    doFirst{
        if (jniMode != JNIUsingMode.compiling_by_custom_task_with_custom_cmake_cfg) {
            commandLine cmd_prefix + ["echo !!!! makeJni Skipped"]
            return
        }
        def cmake_build_dir0_impl = String.format(cmake_build_dir0, build_type.toString().toLowerCase())
        commandLine cmd_prefix + [String.format("%s make%s %s %s", script_prefix, script_suffix, cmake_build_dir0_impl, make_program_bin)]
    }
}
makeJni.dependsOn copyAvalon
tasks.compileLint.dependsOn makeJni

task cleanJni(type: Delete) {
    if(jniMode == JNIUsingMode.compiling_by_custom_task_with_custom_cmake_cfg) {
        delete '.externalNativeBuild'
        delete 'src/main/jniLibs'
    }
    doLast {
        runClean = true
    }
}
rootProject.clean.dependsOn cleanJni

task addTaskDependency {
    doLast {
        if(runClean) {
            genJniHead.enabled = false
            cfgJni.enabled = false
            makeJni.enabled = false
            copyJniLibs.enabled = false
            copyAvalon.enabled = false
            compileReleaseJavaWithJavac.enabled = false;
            for(Task dep: compileReleaseJavaWithJavac.taskDependencies.getDependencies()) {
                if(!dep.didWork)
                    dep.enabled = false;
            }
        }
    }
}
tasks.compileLint.dependsOn addTaskDependency

task copyJniLibs(type: Exec) {
    if (jniMode == JNIUsingMode.using_jnilibs_directly) {
        File file = new File(library_out_dir0);
        if(!file.exists() || (file.isDirectory() && file.list().length == 0))
            commandLine cmd_prefix + [String.format("xcopy %s %s%s /e /i /y", tmpJNILibs, library_out_dir0, File.separator)]
        else
            commandLine cmd_prefix + [String.format("echo !!!! %s is not empty, copyJniLibs Skipped", library_out_dir0)]
        return
    }
    commandLine cmd_prefix + ["echo !!!! nothing to do in copyJniLibs"]
}
tasks.compileLint.dependsOn copyJniLibs

